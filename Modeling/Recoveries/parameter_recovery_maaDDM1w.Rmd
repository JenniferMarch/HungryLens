---
title: "Parameter Recovery maaDDM"
author: "Jennifer March (jennifer.march@uni-hamburg.de)"
date: "2/5/2024"
output: html_document
---

# General Info

This script contains the parameter recovery of the Multi-attribute attentional DDM with starting point of our manuscript (https://osf.io/preprints/psyarxiv/wvfnb). It requires JAGS and the dwiener module. The script is structured s follows:

1. **Preparation:** loading libraries and creating theme for figure and possibility to load our workspace
2. **Set-up Parameter Recovery:** 1x simulate data with parameters 
3. **Fit simulated data:** to check if similar parameters are yielded and correlate recovered with true parameters

# 1 Preparations
## 1.1 Load libraries
```{r}
#clear working environment
rm(list=ls())

#clear all plots
if(!is.null(dev.list())) dev.off()

#load required libraries
library(rtdists)
library(dfoptim)
library(readxl)
library(tidyr)
library(dplyr)
library(zoo)
library(tibble)
library(readr)
pacman::p_load(tidyverse, ez)
#parallel computing stuff
library(parallel)
library(doParallel)
library(foreach)
numCores <- detectCores()
registerDoParallel(cores=numCores)
#JAGS packages
library(R2jags) #should be put at the start but keep it here for the moment...
library(rtdists) #to be on the safe side when loading workspace (and not executing the first chunk above)
```

## 1.2 Create Theme for Plots
```{r}
# Define a custom theme with adjusted text size, line size, and font family
myTheme <- theme_minimal() +
  theme(
    axis.line = element_line(colour = "black"), 
    panel.grid.major = element_blank(),  
    panel.grid.minor = element_blank(),  
    panel.border = element_blank(),      
    panel.background = element_blank(),  
    text = element_text(size = 14, colour = "black", family = "Arial"), 
    axis.title.x = element_text(size = 14, face = "bold", colour = "black", family = "Arial"), 
    axis.title.y = element_text(size = 14, face = "bold", colour = "black", family = "Arial"),
    axis.text = element_text(size = 12, family = "Arial"),
    strip.text = element_text(size = 12, family = "Arial"),
    strip.background = element_rect(fill = "white", colour = "black"),
    legend.background = element_rect(colour = "black"),
    legend.key = element_blank(),
    legend.key.size = unit(3, "lines")
  )

```

## 1.3 Load workspace (if required)
```{r}
# Load workspace 
load("maaDDM.RData")
```

# 2 Set-Up: parameter Recovery 
**Goal:** Simulated data would yield the same parameters
**How:**Draw samples from distribution
```{r}
pr_addmJAGS  <- function(parameters,tasteA,tasteB,healthA,healthB,subject,fixProps){
  
  #extract free parameters; note that order of parameters follows rtdists, not dwiener
  boundarySeparation <- parameters[1]
  ndt <- parameters[2]
  drift <- parameters[3]
  weight1 <- parameters[4]
  theta <- parameters[5]
  phi <- parameters[6] #okay to call it "phi" in R
  startingPoint <- 0.5*boundarySeparation #don't forget: sp is NOT relative in rtdists (but it is in dwiener; gosh!)
  
  #compute trial-wise value difference
  valueDifference <- fixProps[,1]*(weight1*(tasteA-theta*tasteB)+(1-weight1)*phi*(healthA-theta*healthB))+
                     fixProps[,2]*(weight1*(theta*tasteA-tasteB)+(1-weight1)*phi*(theta*healthA-healthB))+
                     fixProps[,3]*(weight1*phi*(tasteA-theta*tasteB)+(1-weight1)*(healthA-theta*healthB))+
                     fixProps[,4]*(weight1*phi*(theta*tasteA-tasteB)+(1-weight1)*(theta*healthA-healthB))

  #Simulate the DDM and store choices and RTs
  nTrials <- length(valueDifference)
  choices <- rep(NA, nTrials)
  rts <- rep(NA, nTrials)
  
  for (i in 1:nTrials) {
    result <- rdiffusion(1,boundarySeparation,drift*valueDifference[i],ndt,startingPoint)
    choices[i] <- ifelse(result$response == "upper", 2, 1)  
    rts[i] <- result$rt
  }
  pr_data<-cbind(subject, choices, rts, tasteA, tasteB, healthA, healthB, fixProps)

    # Return the choices and RTs
  return(pr_data)
}

#generate posterior predictives (loop over samples taken, subjects, conditions)

nParamRecov <- 1
prSample <- sample(addmJAGS$BUGSoutput$n.sims,nParamRecov)#draw samples from posterior (without replacement)
prDat_JAGS_hungry_choices <- matrix(NA,nrow = sum(H==1),ncol = nParamRecov)
prDat_JAGS_sated_choices <- matrix(NA,nrow = sum(H==0),ncol = nParamRecov)
prDat_JAGS_hungry_rts <- matrix(NA,nrow = sum(H==1),ncol = nParamRecov)
prDat_JAGS_sated_rts <- matrix(NA,nrow = sum(H==0),ncol = nParamRecov)
conflictTrials_hungry = c()
conflictTrials_sated = c()

for (p in 1:nParamRecov){
  #x = prSample[p] #current sample
  pr_Dat_JAGS_hungry<-data.frame(choices = numeric(), rts = numeric())
  pr_Dat_JAGS_sated<-data.frame(choices = numeric(), rts = numeric())
  for  (s in (unique(data_sated$subject))){
    sInJAGS <- which(uID==s)
    for (t in 1:2){
      if (t == 1){ #session-specific stuff up front; note that order of parameters follows rtdists, not dwiener
        sub <- data_hungry[data_hungry$subject == s, ] #hungry
        fixatedElement <- expanded_table_h[[which(unique(data_hungry$subject)==s)]]
        
        parameters <- c(log(1+exp(addmJAGS$BUGSoutput$mean$bound[sInJAGS]+addmJAGS$BUGSoutput$mean$bound_H[sInJAGS])),
                      log(1+exp(addmJAGS$BUGSoutput$mean$ndt[sInJAGS]+addmJAGS$BUGSoutput$mean$ndt_H[sInJAGS])),
                      log(1+exp(addmJAGS$BUGSoutput$mean$drift[sInJAGS]+addmJAGS$BUGSoutput$mean$drift_H[sInJAGS])),
                      pnorm(addmJAGS$BUGSoutput$mean$weight1[sInJAGS]+addmJAGS$BUGSoutput$mean$weight1_H[sInJAGS]),
                      (addmJAGS$BUGSoutput$mean$theta[sInJAGS]+addmJAGS$BUGSoutput$mean$theta_H[sInJAGS]),
                      (addmJAGS$BUGSoutput$mean$phy[sInJAGS]+addmJAGS$BUGSoutput$mean$phy_H[sInJAGS]))
      } else {
        sub <- data_sated[data_sated$subject == s, ] #sated
        fixatedElement <- expanded_table_s[[which(unique(data_sated$subject)==s)]]
        parameters <- c(log(1+exp(addmJAGS$BUGSoutput$mean$bound[sInJAGS])),
                      log(1+exp(addmJAGS$BUGSoutput$mean$ndt[sInJAGS])),
                      log(1+exp(addmJAGS$BUGSoutput$mean$drift[sInJAGS])),
                      pnorm(addmJAGS$BUGSoutput$mean$weight1[sInJAGS]),
                      (addmJAGS$BUGSoutput$mean$theta[sInJAGS]),
                      (addmJAGS$BUGSoutput$mean$phy[sInJAGS]))
      }

      #arrange input data
      tasteAi <- sub$taste_left
      tasteBi <- sub$taste_right
      healthAi <- sub$health_left
      healthBi <- sub$health_right
      subjecti <- sub$subject
      ntrialsi <- nrow(sub)
      fixProps <- matrix(nrow = ntrialsi,ncol = 4)
      for (n in 1:ntrialsi){
        fEn <- fixatedElement[1:round(sub$RT[n]),n] #stream of fixated elements in current trials
        fixProps[n,] <- c(sum(na.omit(fEn==1)),sum(na.omit(fEn==2)),sum(na.omit(fEn==3)),sum(na.omit(fEn==4)))/sum(na.omit(fEn>=1))
      }
      #recode everything into tasty vs. healthy choice
      tastyL <- (tasteAi>tasteBi) #whether tasty option was left
      tasteAi <- sub$taste_left*(tastyL==T)+sub$taste_right*(tastyL==F)
      tasteBi <- sub$taste_left*(tastyL==F)+sub$taste_right*(tastyL==T)
      healthAi <- sub$health_left*(tastyL==T)+sub$health_right*(tastyL==F)
      healthBi <- sub$health_left*(tastyL==F)+sub$health_right*(tastyL==T)
      fixProps <- matrix(c(fixProps[,1]*(tastyL==T)+fixProps[,2]*(tastyL==F),fixProps[,1]*(tastyL==F)+fixProps[,2]*(tastyL==T),
                     fixProps[,3]*(tastyL==T)+fixProps[,4]*(tastyL==F),fixProps[,3]*(tastyL==F)+fixProps[,4]*(tastyL==T)),ncol=4)
      #rescale taste and health values to lie between 0 and 10 (as in Yang & Krajbich)
      tasteAi <- tasteAi/10
      tasteBi <- tasteBi/10
      healthAi <- healthAi/10
      healthBi <- healthBi/10
      #take only trials with fixations
      validTrials <- which((is.na(fixProps[,1])==0)|(is.na(fixProps[,2])==0)|(is.na(fixProps[,3])==0)|(is.na(fixProps[,4])==0))
      tasteAi <- tasteAi[validTrials]
      tasteBi <- tasteBi[validTrials]
      healthAi <- healthAi[validTrials]
      healthBi <- healthBi[validTrials]
      subjecti <- subjecti[validTrials]
      fixProps <- fixProps[validTrials,]

      #simulate
      pr_Dat <- pr_addmJAGS(parameters,tasteAi,tasteBi,healthAi,healthBi,subjecti,fixProps)
      if (t==1){
        pr_Dat_JAGS_hungry <- rbind(pr_Dat_JAGS_hungry, pr_Dat)
        if (p==nParamRecov){ #save trial info at the last iteration
          conflictTrials <- ((tasteAi>tasteBi)&(healthAi<healthBi))|((tasteAi<tasteBi)&(healthAi>healthBi))
          conflictTrials_hungry <- c(conflictTrials_hungry,conflictTrials)
        }
      } else {
        pr_Dat_JAGS_sated <- rbind(pr_Dat_JAGS_sated, pr_Dat)
        if (p==nParamRecov){ #save trial info at the last iteration
          conflictTrials <- ((tasteAi>tasteBi)&(healthAi<healthBi))|((tasteAi<tasteBi)&(healthAi>healthBi))
          conflictTrials_sated <- c(conflictTrials_sated,conflictTrials)
        }
      }
    }
  }
  prDat_JAGS_hungry_choices[,p] = pr_Dat_JAGS_hungry$choices
  prDat_JAGS_hungry_rts[,p] = pr_Dat_JAGS_hungry$rts
  prDat_JAGS_sated_choices[,p] = pr_Dat_JAGS_sated$choices
  prDat_JAGS_sated_rts[,p] = pr_Dat_JAGS_sated$rts
  
  flush.console()
  msg = sprintf('Done with parameter recovery: %d',p)
  print(msg)
}

```


# 3 Fit maaDDM + sp
## 3.1 Prepare sim data hungry
```{r}
pr_Dat_JAGS_hungry<-pr_Dat_JAGS_hungry %>% 
  mutate(response=recode(choices, '2'=1, '1'=0))
pr_Dat_JAGS_sated<-pr_Dat_JAGS_sated %>% 
  mutate(response=recode(choices, '2'=1, '1'=0))

#loop over subjects to get the data and arrange it in the order needed
uID <- unique(pr_Dat_JAGS_hungry$subject)
tasteA <- c()
tasteB <- c()
healthA <- c()
healthB <- c()
fixProp1 <- c()
fixProp2 <- c()
fixProp3 <- c()
fixProp4 <- c()
RT <- c()
H <- c() #whether trial is hungry (1) or sated (0)
P <- c() #participant number (from 1 till nsubj, so 1, 2, 3, 4, ..., nsubj)

for (s in (unique(pr_Dat_JAGS_hungry$subject))){
  #loop over sessions (1 = hungry)
  for (t in 1:2){
    if (t == 1){ #session-specific stuff up front
      sub <- pr_Dat_JAGS_hungry[pr_Dat_JAGS_hungry$subject == s, ] #hungry
      #fixatedElement <- expanded_table_h[[which(unique(data_hungry$subject)==s)]]
    } else {
      sub <- pr_Dat_JAGS_sated[pr_Dat_JAGS_sated$subject == s, ] #sated
      #fixatedElement <- expanded_table_s[[which(unique(data_sated$subject)==s)]]
    }
    
    #rearrange input data
    #tastyL <- (sub$taste_left>sub$taste_right) #whether tasty option was left
    response <- sub$response
    #response <- as.numeric(((response==("left"))&(tastyL==T))|((response==("right"))&(tastyL==F)))           #recode response into tasty/healthy chosen (1/0)
    rt_s <- sub$rts
    rt_s[response==0] = -rt_s[response==0] #dwiener function in JAGS wants "negative" rt if choice == 0
    
    tasteA_s <- sub$tasteA
    tasteB_s <- sub$tasteB
    healthA_s <- sub$healthA
    healthB_s <- sub$healthB
    
    #prepare fixation data
    ntrialsi <- nrow(sub)
    fixProps <- sub[, c("V8", "V9", "V10", "V11")]
    
    #fill in "all-subject" vectors
    tasteA <- c(tasteA,tasteA_s)
    tasteB <- c(tasteB,tasteB_s)
    healthA <- c(healthA,healthA_s)
    healthB <- c(healthB,healthB_s)
    fixProp1 <- c(fixProp1,fixProps[,1])
    fixProp2 <- c(fixProp2,fixProps[,2])
    fixProp3 <- c(fixProp3,fixProps[,3])
    fixProp4 <- c(fixProp4,fixProps[,4])
    RT <- c(RT,rt_s)
    H <- c(H,rep(t==1,length(rt_s)))
    P <- c(P,rep(which(uID==s),length(rt_s)))
  }
}

#rescale taste and health values to lie between 0 and 10 (as in Yang & Krajbich)
tasteA <- tasteA/10
tasteB <- tasteB/10
healthA <- healthA/10
healthB <- healthB/10

#take only trials with fixations
#validT <- which((is.na(fixProp1)==0)|(is.na(fixProp2)==0)|(is.na(fixProp3)==0)|(is.na(fixProp4)==0))
#tasteA <- tasteA[validT]
#tasteB <- tasteB[validT]
#healthA <- healthA[validT]
#healthB <- healthB[validT]
#fixProp1 <- fixProp1[validT]
#fixProp2 <- fixProp2[validT]
#fixProp3 <- fixProp3[validT]
#fixProp4 <- fixProp4[validT]
#RT <- RT[validT]
#H <- H[validT]
#P <- P[validT]
N <- length(RT)
S <- length(unique(pr_Dat_JAGS_hungry$subject))
```




## 3.2 maaDDM2 Function
```{r}
# get data and initial values together and specify the model
ddmData <- list('N'=N,'S'=S,'P'=P,'H'=H,'tasteA'=tasteA,'tasteB'=tasteB,'healthA'=healthA,'healthB'=healthB,'RT'=RT,
                'fixProp1'=fixProp1,'fixProp2'=fixProp2,'fixProp3'=fixProp3,'fixProp4'=fixProp4)

#starting values
nChains <- 8

#parallel computing apparently not possible
T1<-Sys.time()
addmJAGS_recov <- jags.parallel(ddmData,inits = NULL,#jags.seed = sample(100:999,1),
                    parameters.to.save = c('mu_bound','sigma_bound','mu_ndt','sigma_ndt',
                                           'mu_drift', 'sigma_drift','mu_weight1','sigma_weight1',
                                           'mu_theta','sigma_theta','mu_phy','sigma_phy',
                                           'mu_bound_H','sigma_bound_H','mu_ndt_H','sigma_ndt_H',
                                           'mu_drift_H','sigma_drift_H','mu_weight1_H','sigma_weight1_H',
                                           'mu_theta_H','sigma_theta_H','mu_phy_H','sigma_phy_H',
                                           'bound','ndt','drift','weight1','theta','phy',
                                           'bound_H','ndt_H','drift_H','weight1_H','theta_H','phy_H'),
                    model.file = "BayesModel_maaDDM.txt",working.directory = 'BayesModels',
                    n.chains = nChains, n.iter = 60000, n.burnin = 30000,n.thin = 12, DIC = TRUE,jags.module = c("glm","dic","wiener"))
T2<-Sys.time() #T2-T1

# check convergence
ddmRhats <- addmJAGS_recov$BUGSoutput$summary[,8] #check with max(Rhats), which should ideally be < 1.01 (1.05 would also be okay)
max(ddmRhats)
addmJAGS_recov$BUGSoutput$DIC

save.image(file = "param_recov_maaDDM.RData")
```

## 3.3 Correlate with true parameters
### 3.3.1 Correlations
```{r}
#correlations always sated and hungry for each parameter: bound, ndt, starting point, taste weight, health weight, theta and phi
cor(addmJAGS_recov$BUGSoutput$mean$bound, addmJAGS$BUGSoutput$mean$bound)
cor(addmJAGS_recov$BUGSoutput$mean$bound+addmJAGS_recov$BUGSoutput$mean$bound_H, addmJAGS$BUGSoutput$mean$bound+addmJAGS$BUGSoutput$mean$bound_H)
cor(addmJAGS_recov$BUGSoutput$mean$ndt, addmJAGS$BUGSoutput$mean$ndt)
cor(addmJAGS_recov$BUGSoutput$mean$ndt+addmJAGS_recov$BUGSoutput$mean$ndt_H, addmJAGS$BUGSoutput$mean$ndt+addmJAGS$BUGSoutput$mean$ndt_H)
cor(addmJAGS_recov$BUGSoutput$mean$weight1, addmJAGS$BUGSoutput$mean$weight1)
cor(addmJAGS_recov$BUGSoutput$mean$weight1+addmJAGS_recov$BUGSoutput$mean$weight1_H, addmJAGS$BUGSoutput$mean$weight1+addmJAGS$BUGSoutput$mean$weight1_H)

cor(addmJAGS_recov$BUGSoutput$mean$theta, addmJAGS$BUGSoutput$mean$theta)
cor(addmJAGS_recov$BUGSoutput$mean$theta+addmJAGS_recov$BUGSoutput$mean$theta_H, addmJAGS$BUGSoutput$mean$theta+addmJAGS$BUGSoutput$mean$theta_H)
cor(addmJAGS_recov$BUGSoutput$mean$phy, addmJAGS$BUGSoutput$mean$phy)
cor(addmJAGS_recov$BUGSoutput$mean$phy+addmJAGS_recov$BUGSoutput$mean$phy_H, addmJAGS$BUGSoutput$mean$phy+addmJAGS$BUGSoutput$mean$phy_H)

cor(addmJAGS_recov$BUGSoutput$mean$drift, addmJAGS$BUGSoutput$mean$drift)
cor((addmJAGS_recov$BUGSoutput$mean$drift+addmJAGS_recov$BUGSoutput$mean$drift_H),(addmJAGS$BUGSoutput$mean$drift+addmJAGS$BUGSoutput$mean$drift_H))
```

### 3.3.2 Graphs
```{r}
# a) Boundary seperation
bound_rec <- data.frame(
  rec_sated = log(1+exp(addmJAGS_recov$BUGSoutput$mean$bound)),
  true_sated = log(1+exp(addmJAGS$BUGSoutput$mean$bound)),
  rec_hungry = log(1+exp(addmJAGS_recov$BUGSoutput$mean$bound+addmJAGS_recov$BUGSoutput$mean$bound_H)),
  true_hungry = log(1+exp(addmJAGS$BUGSoutput$mean$bound+addmJAGS$BUGSoutput$mean$bound_H))
)

# Plot
bound_pr <- ggplot(bound_rec) +
  geom_point(aes(x = true_sated, y = rec_sated), color = "cornflowerblue", alpha = 0.7) +
  geom_point(aes(x = true_hungry, y = rec_hungry), color = "gold", alpha = 0.7) +
  geom_abline(intercept = 0, slope = 1, color = "black", linetype = "solid") +
  labs(title = "",
       x = "bound (true)",
       y = "bound (recovered)",
       color = "Condition") +
  #geom_text(aes(x = 5, y = 0.5, label = sprintf("R(sated): %.2f", cor(bound_rec$rec_sated, bound_rec$true_sated))),hjust = 1, vjust = 0, color = "black") +
  #geom_text(aes(x = 5, y = 0.1, label = sprintf("R(hungry): %.2f", cor(bound_rec$rec_hungry, bound_rec$true_hungry))),hjust = 1, vjust = 1, color = "black") +
  ylim(0, 5) +
  xlim(0, 5) +
  myTheme


# b) NDT
ndt_rec <- data.frame(
  rec_sated = log(1+exp(addmJAGS_recov$BUGSoutput$mean$ndt)),
  true_sated = log(1+exp(addmJAGS$BUGSoutput$mean$ndt)),
  rec_hungry = log(1+exp(addmJAGS_recov$BUGSoutput$mean$ndt+addmJAGS_recov$BUGSoutput$mean$ndt_H)),
  true_hungry = log(1+exp(addmJAGS$BUGSoutput$mean$ndt+addmJAGS$BUGSoutput$mean$ndt_H))
)

# Plot
ndt_pr <-ggplot(ndt_rec) +
  geom_point(aes(x = true_sated, y = rec_sated), color = "cornflowerblue", alpha = 0.7) +
  geom_point(aes(x = true_hungry, y = rec_hungry), color = "gold", alpha = 0.7) +
  geom_abline(intercept = 0, slope = 1, color = "black", linetype = "solid") +
  labs(title = "",
       x = "ndt (true)",
       y = "ndt (recovered)",
       color = "Condition") +
  ylim(0,2)+
  xlim(0,2)+
  myTheme

# c) taste weight
taste_rec <- data.frame(
  rec_sated = pnorm(addmJAGS_recov$BUGSoutput$mean$weight1),
  true_sated = pnorm(addmJAGS$BUGSoutput$mean$weight1),
  rec_hungry = pnorm((addmJAGS_recov$BUGSoutput$mean$weight1+addmJAGS_recov$BUGSoutput$mean$weight1_H)),
  true_hungry = pnorm((addmJAGS$BUGSoutput$mean$weight1+addmJAGS$BUGSoutput$mean$weight1_H))
)

# Plot
taste_pr <-ggplot(taste_rec) +
  geom_point(aes(x = true_sated, y = rec_sated), color = "cornflowerblue", alpha = 0.7) +
  geom_point(aes(x = true_hungry, y = rec_hungry), color = "gold", alpha = 0.7) +
  geom_abline(intercept = 0, slope = 1, color = "black", linetype = "solid") +
  labs(title = "",
       x = "taste weight (true)",
       y = "taste weight (recovered)",
       color = "Condition") +
  #ylim(0,0.5)+
  #xlim(0,0.5)+
  myTheme

# d) drift
health_rec <- data.frame(
  rec_sated = log(1+exp(addmJAGS_recov$BUGSoutput$mean$drift))/10,
  true_sated = log(1+exp(addmJAGS$BUGSoutput$mean$drift)),
  rec_hungry = log(1+exp(addmJAGS_recov$BUGSoutput$mean$drift+addmJAGS_recov$BUGSoutput$mean$drift_H))/10,
  true_hungry = log(1+exp(addmJAGS$BUGSoutput$mean$drift+addmJAGS$BUGSoutput$mean$drift_H))
)

# Plot
health_pr <-ggplot(health_rec) +
  geom_point(aes(x = true_sated, y = rec_sated), color = "cornflowerblue", alpha = 0.7) +
  geom_point(aes(x = true_hungry, y = rec_hungry), color = "gold", alpha = 0.7) +
  geom_abline(intercept = 0, slope = 1, color = "black", linetype = "solid") +
  labs(title = "",
       x = "drift (true)",
       y = "drift (recovered)",
       color = "Condition") +
  #ylim(0,0.5)+
  #xlim(0,0.5)+
  myTheme

# e) theta
theta_rec <- data.frame(
  rec_sated = (addmJAGS_recov$BUGSoutput$mean$theta),
  true_sated = (addmJAGS$BUGSoutput$mean$theta),
  rec_hungry = (addmJAGS_recov$BUGSoutput$mean$theta+addmJAGS_recov$BUGSoutput$mean$theta_H),
  true_hungry = (addmJAGS$BUGSoutput$mean$theta+addmJAGS$BUGSoutput$mean$theta_H)
)

# Plot
theta_pr <-ggplot(theta_rec) +
  geom_point(aes(x = true_sated, y = rec_sated), color = "cornflowerblue", alpha = 0.7) +
  geom_point(aes(x = true_hungry, y = rec_hungry), color = "gold", alpha = 0.7) +
  geom_abline(intercept = 0, slope = 1, color = "black", linetype = "solid") +
  labs(title = "",
       x = "theta (true)",
       y = "theta (recovered)",
       color = "Condition") +
  ylim(0,1)+
  xlim(0,1)+
  myTheme

# f) phi
phi_rec <- data.frame(
  rec_sated = (addmJAGS_recov$BUGSoutput$mean$phy),
  true_sated = (addmJAGS$BUGSoutput$mean$phy),
  rec_hungry = (addmJAGS_recov$BUGSoutput$mean$phy+addmJAGS_recov$BUGSoutput$mean$phy_H),
  true_hungry = (addmJAGS$BUGSoutput$mean$phy+addmJAGS$BUGSoutput$mean$phy_H)
)

# Plot
phi_pr <-ggplot(phi_rec) +
  geom_point(aes(x = true_sated, y = rec_sated), color = "cornflowerblue", alpha = 0.7) +
  geom_point(aes(x = true_hungry, y = rec_hungry), color = "gold", alpha = 0.7) +
  geom_abline(intercept = 0, slope = 1, color = "black", linetype = "solid") +
  labs(title = "",
       x = "phi (true)",
       y = "phi (recovered)",
       color = "Condition") +
  ylim(0,1)+
  xlim(0,1)+
  myTheme


library("cowplot")
# Arrange the plots side by side
recov_plot_maaddm <- plot_grid(taste_pr, health_pr, ndt_pr,bound_pr, theta_pr, phi_pr, labels = c("a","b", "c", "d", "e", "f"), label_size = 20, ncol = 4, align = "h")
recov_plot_maaddm
# Save the combined plot as a PNG file
ggsave("recov_plot_maaddm.png", recov_plot_maaddm, width = 18, height = 9)
```

